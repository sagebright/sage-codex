/**
 * Invoking stage tool handlers
 *
 * Implements the tool handlers for the Invoking stage:
 * - set_spark: Captures the user's adventure vision
 * - signal_ready: Signals the stage is ready for advancement
 *
 * These handlers are registered with the tool dispatcher and called
 * when Claude invokes the corresponding tools during conversation.
 */

import { registerToolHandler } from '../services/tool-dispatcher.js';
import { getSupabase } from '../services/supabase.js';
import type { SageEvent } from '@dagger-app/shared-types';

// =============================================================================
// Types
// =============================================================================

interface SetSparkInput {
  name: string;
  vision: string;
}

interface SignalReadyInput {
  stage: string;
  summary: string;
}

// =============================================================================
// Event Builders
// =============================================================================

/**
 * Build a panel:spark SSE event from the tool input.
 */
function buildSparkEvent(input: SetSparkInput): SageEvent {
  return {
    type: 'panel:spark',
    data: {
      name: input.name,
      vision: input.vision,
    },
  };
}

/**
 * Build a ui:ready SSE event from the tool input.
 */
function buildReadyEvent(input: SignalReadyInput): SageEvent {
  return {
    type: 'ui:ready',
    data: {
      stage: input.stage,
      summary: input.summary,
    },
  };
}

// =============================================================================
// Pending Events Queue
// =============================================================================

/**
 * Events generated by tool handlers that need to be sent to the client.
 *
 * The chat route collects these after tool dispatch and sends them as SSE.
 * This avoids coupling the tool handler to the response object.
 */
let pendingEvents: SageEvent[] = [];

/**
 * Get and clear all pending events from tool handlers.
 */
export function drainPendingEvents(): SageEvent[] {
  const events = [...pendingEvents];
  pendingEvents = [];
  return events;
}

// =============================================================================
// Tool Handlers
// =============================================================================

/**
 * Register all Invoking stage tool handlers.
 *
 * Called once at server startup to wire up the handlers.
 */
export function registerInvokingTools(): void {
  registerToolHandler('set_spark', handleSetSpark);
  registerToolHandler('signal_ready', handleSignalReady);
}

/**
 * Handle the set_spark tool call.
 *
 * Captures the user's adventure vision and queues a panel:spark
 * event for the frontend to update the SparkPanel.
 */
async function handleSetSpark(
  input: Record<string, unknown>
): Promise<{ result: unknown; isError: boolean }> {
  const sparkInput = input as unknown as SetSparkInput;

  if (!sparkInput.name || !sparkInput.vision) {
    return {
      result: 'Both name and vision are required for set_spark',
      isError: true,
    };
  }

  // Queue the panel:spark event for the frontend
  pendingEvents.push(buildSparkEvent(sparkInput));

  // Save spark to adventure state in Supabase (best effort)
  try {
    await persistSparkToState(sparkInput);
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    console.error(`Failed to persist spark: ${message}`);
  }

  return {
    result: {
      status: 'spark_captured',
      name: sparkInput.name,
      vision: sparkInput.vision,
    },
    isError: false,
  };
}

/**
 * Handle the signal_ready tool call.
 *
 * Signals that the current stage is complete and the user can advance.
 * Queues a ui:ready event for the frontend.
 */
async function handleSignalReady(
  input: Record<string, unknown>
): Promise<{ result: unknown; isError: boolean }> {
  const readyInput = input as unknown as SignalReadyInput;

  if (!readyInput.stage) {
    return {
      result: 'stage is required for signal_ready',
      isError: true,
    };
  }

  // Queue the ui:ready event for the frontend
  pendingEvents.push(buildReadyEvent(readyInput));

  return {
    result: {
      status: 'ready_signaled',
      stage: readyInput.stage,
      summary: readyInput.summary ?? '',
    },
    isError: false,
  };
}

// =============================================================================
// Persistence
// =============================================================================

/**
 * Persist the spark data to the adventure state in Supabase.
 *
 * Updates the sage_adventure_state JSONB column with the spark data.
 * This is best-effort — failures are logged but don't block the tool call.
 */
async function persistSparkToState(spark: SetSparkInput): Promise<void> {
  const supabase = getSupabase();

  // Update adventure state with the spark
  // Note: This updates all rows — in practice, the chat route should
  // pass the session ID to scope the update. For now, this is a placeholder.
  const { error } = await supabase.rpc('update_adventure_spark', {
    p_spark: { name: spark.name, vision: spark.vision },
  });

  if (error) {
    // If the RPC doesn't exist yet, log but don't fail
    console.warn(`Spark persistence RPC not available: ${error.message}`);
  }
}
